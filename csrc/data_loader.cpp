// Note to self: generated by Gemini

#include "data_loader.hpp"
#include <iostream>
#include <fstream>
#include <sstream>

// Function definition for reading points
bool readPointsFromFile(const std::string& filename, Dataset& points) {
    // Clear any existing data in the vector
    points.clear(); 

    std::ifstream inputFile(filename);

    if (!inputFile.is_open()) {
        std::cerr << "Error: Could not open the file '" << filename << "'.\n";
        return false;
    }

    std::string line;
    // Read the file line by line
    while (std::getline(inputFile, line)) {
        // Skip empty lines
        if (line.empty() || line.find_first_not_of(" \t\n\r") == std::string::npos) {
            continue;
        }

        std::stringstream ss(line);
        Point currentPoint;
        float coord;

        // Extract floating-point numbers sequentially from the line stream
        while (ss >> coord) {
            currentPoint.push_back(coord);
        }
        
        // Check for any formatting errors within the line
        if (ss.fail() && !ss.eof()) {
            std::cerr << "Warning: Skipping line due to invalid data format: " << line << "\n";
            continue;
        }

        // Only store the point if at least one coordinate was read
        if (!currentPoint.empty()) {
            points.push_back(currentPoint);
        }
    }

    inputFile.close();
    return true;
}

// Function definition for printing points
void print_points(const Dataset& points) {
    if (points.empty()) {
        std::cout << "No points were loaded.\n";
        return;
    }
    std::cout << "Successfully loaded " << points.size() << " points:\n";
    
    for (size_t i = 0; i < points.size(); ++i) {
        std::cout << "Point " << i + 1 << " (Dim: " << points[i].size() << "): (";
        
        for (size_t j = 0; j < points[i].size(); ++j) {
            std::cout << points[i][j] << (j < points[i].size() - 1 ? ", " : "");
        }
        std::cout << ")\n";
    }
}
